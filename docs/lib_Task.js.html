<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/Task.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/Task.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

/**
 * Represent a task. You don't instantiate this class directly, instead you should use {@link Coordinator#schedule}
 * @param {Coordinator} coordinator
 * @param {string} name
 * @param {number} interval
 * @param {number} timeout
 * @param {Coordinator~runTask} fn
 * @class
 */
function Task(coordinator, name, interval, timeout, fn) {
	/** @member {Coordinator} */
	this.coordinator = coordinator

	/** @member {string} */
	this.name = name

	/** @member {number} */
	this.interval = interval

	/** @member {number} */
	this.timeout = timeout

	/** @member {Coordinator~runTask} */
	this.fn = fn

	/** @member {boolean} */
	this.running = false

	/**
	 * Task timer
	 * @member {Timer}
	 * @private
	 */
	this._timer = null

	this.start()
}

module.exports = Task

/**
 * Stop scheduling this task.
 * Note that this will *not* stop a currently running operation
 */
Task.prototype.stop = function () {
	clearTimeout(this._timer)
}

/**
 * Schedule next execution for this task
 */
Task.prototype.start = function () {
	var now = Date.now(),
		next = Math.ceil((now + 1) / this.interval) * this.interval,
		dt = next - now

	clearTimeout(this._timer)
	this._timer = setTimeout(this._run.bind(this), dt)
}

/**
 * Try to acquire lock and run the task
 * @private
 */
Task.prototype._run = function () {
	var that = this,
		now = Date.now(),
		intervalId = Math.floor((now + 1) / this.interval)

	this.start()

	if (this.running) {
		return
	}
	this.running = true

	this.coordinator._acquireLock(this, intervalId, function (lock) {
		var timeoutTimer

		if (!lock) {
			// Someone elsewhere took the lock
			that.running = false
			return
		}

		// Set timeout interval
		if (that.timeout) {
			timeoutTimer = setTimeout(that._handleTimeout.bind(that), that.timeout).unref()
		}

		// Jump to user code
		var released = false
		that.fn(function () {
			if (released) {
				// Ops, double releasing is not allowed
				throw new Error('Lock already released')
			}
			released = true

			that.running = false
			clearTimeout(timeoutTimer)
			lock.release()
		})
	})
}

/**
 * Detect timeouts. This is probably because the user forgot to call done()
 * @private
 */
Task.prototype._handleTimeout = function () {
	this.running = false
	this.coordinator.emit('timeout', this)
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Coordinator.html">Coordinator</a></li><li><a href="Task.html">Task</a></li></ul><h3>Events</h3><ul><li><a href="Coordinator.html#event:possibleOverrun">possibleOverrun</a></li><li><a href="Coordinator.html#event:timeout">timeout</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Tue Sep 08 2015 12:44:37 GMT-0300 (Hora oficial do Brasil)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
